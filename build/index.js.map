{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["import * as React from \"react\";\nimport PropTypes from \"prop-types\";\nimport warning from \"warning\";\nimport { constant, checkIndexBounds, computeIndex, getDisplaySameSlide } from \"react-swipeable-views-core\";\n\nfunction addEventListener(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return {\n        remove() {\n            node.removeEventListener(event, handler, options);\n        },\n    };\n}\n\nconst styles = {\n    container: {\n        direction: \"ltr\",\n        display: \"flex\",\n        willChange: \"transform\",\n    },\n    slide: {\n        width: \"100%\",\n        WebkitFlexShrink: 0,\n        flexShrink: 0,\n        overflow: \"auto\",\n    },\n};\n\nconst axisProperties = {\n    root: {\n        x: {\n            overflowX: \"hidden\",\n        },\n        \"x-reverse\": {\n            overflowX: \"hidden\",\n        },\n        y: {\n            overflowY: \"hidden\",\n        },\n        \"y-reverse\": {\n            overflowY: \"hidden\",\n        },\n    },\n    flexDirection: {\n        x: \"row\",\n        \"x-reverse\": \"row-reverse\",\n        y: \"column\",\n        \"y-reverse\": \"column-reverse\",\n    },\n    transform: {\n        x: (translate) => `translate(${-translate}%, 0)`,\n        \"x-reverse\": (translate) => `translate(${translate}%, 0)`,\n        y: (translate) => `translate(0, ${-translate}%)`,\n        \"y-reverse\": (translate) => `translate(0, ${translate}%)`,\n    },\n    length: {\n        x: \"width\",\n        \"x-reverse\": \"width\",\n        y: \"height\",\n        \"y-reverse\": \"height\",\n    },\n    rotationMatrix: {\n        x: {\n            x: [1, 0],\n            y: [0, 1],\n        },\n        \"x-reverse\": {\n            x: [-1, 0],\n            y: [0, 1],\n        },\n        y: {\n            x: [0, 1],\n            y: [1, 0],\n        },\n        \"y-reverse\": {\n            x: [0, -1],\n            y: [1, 0],\n        },\n    },\n    scrollPosition: {\n        x: \"scrollLeft\",\n        \"x-reverse\": \"scrollLeft\",\n        y: \"scrollTop\",\n        \"y-reverse\": \"scrollTop\",\n    },\n    scrollLength: {\n        x: \"scrollWidth\",\n        \"x-reverse\": \"scrollWidth\",\n        y: \"scrollHeight\",\n        \"y-reverse\": \"scrollHeight\",\n    },\n    clientLength: {\n        x: \"clientWidth\",\n        \"x-reverse\": \"clientWidth\",\n        y: \"clientHeight\",\n        \"y-reverse\": \"clientHeight\",\n    },\n};\n\nfunction createTransition(property, options) {\n    const { duration, easeFunction, delay } = options;\n\n    return `${property} ${duration} ${easeFunction} ${delay}`;\n}\n\n// We are using a 2x2 rotation matrix.\nfunction applyRotationMatrix(touch, axis) {\n    const rotationMatrix = axisProperties.rotationMatrix[axis];\n\n    return {\n        pageX: rotationMatrix.x[0] * touch.pageX + rotationMatrix.x[1] * touch.pageY,\n        pageY: rotationMatrix.y[0] * touch.pageX + rotationMatrix.y[1] * touch.pageY,\n    };\n}\n\nfunction adaptMouse(event) {\n    event.touches = [{ pageX: event.pageX, pageY: event.pageY }];\n    return event;\n}\n\nexport function getDomTreeShapes(element, rootNode) {\n    let domTreeShapes = [];\n\n    while (element && element !== rootNode && element !== document.body) {\n        // We reach a Swipeable View, no need to look higher in the dom tree.\n        if (element.hasAttribute(\"data-swipeable\")) {\n            break;\n        }\n\n        const style = window.getComputedStyle(element);\n\n        if (\n            // Ignore the scroll children if the element is absolute positioned.\n            style.getPropertyValue(\"position\") === \"absolute\" ||\n            // Ignore the scroll children if the element has an overflowX hidden\n            style.getPropertyValue(\"overflow-x\") === \"hidden\"\n        ) {\n            domTreeShapes = [];\n        } else if (\n            (element.clientWidth > 0 && element.scrollWidth > element.clientWidth) ||\n            (element.clientHeight > 0 && element.scrollHeight > element.clientHeight)\n        ) {\n            // Ignore the nodes that have no width.\n            // Keep elements with a scroll\n            domTreeShapes.push({\n                element,\n                scrollWidth: element.scrollWidth,\n                scrollHeight: element.scrollHeight,\n                clientWidth: element.clientWidth,\n                clientHeight: element.clientHeight,\n                scrollLeft: element.scrollLeft,\n                scrollTop: element.scrollTop,\n            });\n        }\n\n        element = element.parentNode;\n    }\n\n    return domTreeShapes;\n}\n\n// We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\nlet nodeWhoClaimedTheScroll = null;\n\nexport function findNativeHandler(params) {\n    const { domTreeShapes, pageX, startX, axis } = params;\n\n    return domTreeShapes.some((shape) => {\n        // Determine if we are going backward or forward.\n        let goingForward = pageX >= startX;\n        if (axis === \"x\" || axis === \"y\") {\n            goingForward = !goingForward;\n        }\n\n        // scrollTop is not always be an integer.\n        // https://github.com/jquery/api.jquery.com/issues/608\n        const scrollPosition = Math.round(shape[axisProperties.scrollPosition[axis]]);\n\n        const areNotAtStart = scrollPosition > 0;\n        const areNotAtEnd = scrollPosition + shape[axisProperties.clientLength[axis]] < shape[axisProperties.scrollLength[axis]];\n\n        if ((goingForward && areNotAtEnd) || (!goingForward && areNotAtStart)) {\n            nodeWhoClaimedTheScroll = shape.element;\n            return true;\n        }\n\n        return false;\n    });\n}\n\nexport const SwipeableViewsContext = React.createContext();\n\nif (process.env.NODE_ENV !== \"production\") {\n    SwipeableViewsContext.displayName = \"SliderViewsContext\";\n}\n\nclass SliderViews extends React.Component {\n    rootNode = null;\n    containerNode = null;\n    ignoreNextScrollEvents = false;\n    viewLength = 0;\n    startX = 0;\n    lastX = 0;\n    vx = 0;\n    startY = 0;\n    isSwiping = undefined;\n    started = false;\n    startIndex = 0;\n    transitionListener = null;\n    touchMoveListener = null;\n    activeSlide = null;\n    indexCurrent = null;\n    firstRenderTimeout = null;\n\n    constructor(props) {\n        super(props);\n\n        if (process.env.NODE_ENV !== \"production\") {\n            checkIndexBounds(props);\n        }\n\n        this.state = {\n            indexLatest: props.index,\n            // Set to true as soon as the component is swiping.\n            // It's the state counter part of this.isSwiping.\n            isDragging: false,\n            // Help with SSR logic and lazy loading logic.\n            renderOnlyActive: !props.disableLazyLoading,\n            heightLatest: 0,\n            // Let the render method that we are going to display the same slide than previously.\n            displaySameSlide: true,\n        };\n        this.setIndexCurrent(props.index);\n    }\n\n    componentDidMount() {\n        // Subscribe to transition end events.\n        this.transitionListener = addEventListener(this.containerNode, \"transitionend\", (event) => {\n            if (event.target !== this.containerNode) {\n                return;\n            }\n\n            this.handleTransitionEnd();\n        });\n\n        // Block the thread to handle that event.\n        this.touchMoveListener = addEventListener(\n            this.rootNode,\n            \"touchmove\",\n            (event) => {\n                // Handling touch events is disabled.\n                if (this.props.disabled) {\n                    return;\n                }\n                this.handleSwipeMove(event);\n            },\n            {\n                passive: false,\n            }\n        );\n\n        if (!this.props.disableLazyLoading) {\n            this.firstRenderTimeout = setTimeout(() => {\n                this.setState({\n                    renderOnlyActive: false,\n                });\n            }, 0);\n        }\n\n        // Send all functions in an object if action param is set.\n        if (this.props.action) {\n            this.props.action({\n                updateHeight: this.updateHeight,\n            });\n        }\n    }\n\n    // UNSAFE_componentWillReceiveProps(nextProps) {\n    //     const { index } = nextProps;\n\n    //     if (typeof index === \"number\" && index !== this.props.index) {\n    //         if (process.env.NODE_ENV !== \"production\") {\n    //             checkIndexBounds(nextProps);\n    //         }\n\n    //         this.setIndexCurrent(index);\n    //         this.setState({\n    //             // If true, we are going to change the children. We shoudn't animate it.\n    //             displaySameSlide: getDisplaySameSlide(this.props, nextProps),\n    //             indexLatest: index,\n    //         });\n    //     }\n    // }\n\n    /**\n     *\n     * @param {import(\"../build\").ReactSliderViewsProps} prevProps\n     * @param {any} prevState\n     */\n    componentDidUpdate(prevProps, prevState) {\n        const { index } = this.props;\n        if (typeof index === \"number\" && index !== prevProps.index) {\n            if (process.env.NODE_ENV !== \"production\") {\n                checkIndexBounds(this.props);\n            }\n\n            this.setIndexCurrent(index);\n            this.setState({\n                // If true, we are going to change the children. We shoudn't animate it.\n                displaySameSlide: getDisplaySameSlide(prevProps, this.props),\n                indexLatest: index,\n            });\n        }\n    }\n\n    componentWillUnmount() {\n        this.transitionListener.remove();\n        this.touchMoveListener.remove();\n        clearTimeout(this.firstRenderTimeout);\n    }\n\n    getSwipeableViewsContext() {\n        return {\n            slideUpdateHeight: () => {\n                this.updateHeight();\n            },\n        };\n    }\n\n    setIndexCurrent(indexCurrent) {\n        if (!this.props.animateTransitions && this.indexCurrent !== indexCurrent) {\n            this.handleTransitionEnd();\n        }\n\n        this.indexCurrent = indexCurrent;\n\n        if (this.containerNode) {\n            const { axis } = this.props;\n            const transform = axisProperties.transform[axis](indexCurrent * 100);\n            this.containerNode.style.WebkitTransform = transform;\n            this.containerNode.style.transform = transform;\n        }\n    }\n\n    setRootNode = (node) => {\n        this.rootNode = node;\n    };\n\n    setContainerNode = (node) => {\n        this.containerNode = node;\n    };\n\n    setActiveSlide = (node) => {\n        this.activeSlide = node;\n        this.updateHeight();\n    };\n\n    handleSwipeStart = (event) => {\n        const { axis } = this.props;\n\n        const touch = applyRotationMatrix(event.touches[0], axis);\n\n        this.viewLength = this.rootNode.getBoundingClientRect()[axisProperties.length[axis]];\n        this.startX = touch.pageX;\n        this.lastX = touch.pageX;\n        this.vx = 0;\n        this.startY = touch.pageY;\n        this.isSwiping = undefined;\n        this.started = true;\n\n        const computedStyle = window.getComputedStyle(this.containerNode);\n        const transform = computedStyle.getPropertyValue(\"-webkit-transform\") || computedStyle.getPropertyValue(\"transform\");\n\n        if (transform && transform !== \"none\") {\n            const transformValues = transform.split(\"(\")[1].split(\")\")[0].split(\",\");\n            const rootStyle = window.getComputedStyle(this.rootNode);\n\n            const tranformNormalized = applyRotationMatrix(\n                {\n                    pageX: parseInt(transformValues[4], 10),\n                    pageY: parseInt(transformValues[5], 10),\n                },\n                axis\n            );\n\n            this.startIndex =\n                -tranformNormalized.pageX / (this.viewLength - parseInt(rootStyle.paddingLeft, 10) - parseInt(rootStyle.paddingRight, 10)) || 0;\n        }\n    };\n\n    handleSwipeMove = (event) => {\n        // The touch start event can be cancel.\n        // Makes sure we set a starting point.\n        if (!this.started) {\n            this.handleTouchStart(event);\n            return;\n        }\n\n        // We are not supposed to hanlde this touch move.\n        if (nodeWhoClaimedTheScroll !== null && nodeWhoClaimedTheScroll !== this.rootNode) {\n            return;\n        }\n\n        const { axis, children, ignoreNativeScroll, onSwitching, resistance } = this.props;\n        const touch = applyRotationMatrix(event.touches[0], axis);\n\n        // We don't know yet.\n        if (this.isSwiping === undefined) {\n            const dx = Math.abs(touch.pageX - this.startX);\n            const dy = Math.abs(touch.pageY - this.startY);\n\n            const isSwiping = dx > dy && dx > constant.UNCERTAINTY_THRESHOLD;\n\n            // We let the parent handle the scroll.\n            if (\n                !resistance &&\n                (axis === \"y\" || axis === \"y-reverse\") &&\n                ((this.indexCurrent === 0 && this.startX < touch.pageX) ||\n                    (this.indexCurrent === React.Children.count(this.props.children) - 1 && this.startX > touch.pageX))\n            ) {\n                this.isSwiping = false;\n                return;\n            }\n\n            // We are likely to be swiping, let's prevent the scroll event.\n            if (dx > dy) {\n                event.preventDefault();\n            }\n\n            if (isSwiping === true || dy > constant.UNCERTAINTY_THRESHOLD) {\n                this.isSwiping = isSwiping;\n                this.startX = touch.pageX; // Shift the starting point.\n\n                return; // Let's wait the next touch event to move something.\n            }\n        }\n\n        if (this.isSwiping !== true) {\n            return;\n        }\n\n        // We are swiping, let's prevent the scroll event.\n        event.preventDefault();\n\n        // Low Pass filter.\n        this.vx = this.vx * 0.5 + (touch.pageX - this.lastX) * 0.5;\n        this.lastX = touch.pageX;\n\n        const { index, startX } = computeIndex({\n            children,\n            resistance,\n            pageX: touch.pageX,\n            startIndex: this.startIndex,\n            startX: this.startX,\n            viewLength: this.viewLength,\n        });\n\n        // Add support for native scroll elements.\n        if (nodeWhoClaimedTheScroll === null && !ignoreNativeScroll) {\n            const domTreeShapes = getDomTreeShapes(event.target, this.rootNode);\n            const hasFoundNativeHandler = findNativeHandler({\n                domTreeShapes,\n                startX: this.startX,\n                pageX: touch.pageX,\n                axis,\n            });\n\n            // We abort the touch move handler.\n            if (hasFoundNativeHandler) {\n                return;\n            }\n        }\n\n        // We are moving toward the edges.\n        if (startX) {\n            this.startX = startX;\n        } else if (nodeWhoClaimedTheScroll === null) {\n            nodeWhoClaimedTheScroll = this.rootNode;\n        }\n\n        this.setIndexCurrent(index);\n\n        const callback = () => {\n            if (onSwitching) {\n                onSwitching(index, \"move\");\n            }\n        };\n\n        if (this.state.displaySameSlide || !this.state.isDragging) {\n            this.setState(\n                {\n                    displaySameSlide: false,\n                    isDragging: true,\n                },\n                callback\n            );\n        }\n\n        callback();\n    };\n\n    handleSwipeEnd = () => {\n        nodeWhoClaimedTheScroll = null;\n\n        // The touch start event can be cancel.\n        // Makes sure that a starting point is set.\n        if (!this.started) {\n            return;\n        }\n\n        this.started = false;\n\n        if (this.isSwiping !== true) {\n            return;\n        }\n\n        const indexLatest = this.state.indexLatest;\n        const indexCurrent = this.indexCurrent;\n        const delta = indexLatest - indexCurrent;\n\n        let indexNew;\n\n        // Quick movement\n        if (Math.abs(this.vx) > this.props.threshold) {\n            if (this.vx > 0) {\n                indexNew = Math.floor(indexCurrent);\n            } else {\n                indexNew = Math.ceil(indexCurrent);\n            }\n        } else if (Math.abs(delta) > this.props.hysteresis) {\n            // Some hysteresis with indexLatest.\n            indexNew = delta > 0 ? Math.floor(indexCurrent) : Math.ceil(indexCurrent);\n        } else {\n            indexNew = indexLatest;\n        }\n\n        const indexMax = React.Children.count(this.props.children) - 1;\n\n        if (indexNew < 0) {\n            indexNew = 0;\n        } else if (indexNew > indexMax) {\n            indexNew = indexMax;\n        }\n\n        this.setIndexCurrent(indexNew);\n        this.setState(\n            {\n                indexLatest: indexNew,\n                isDragging: false,\n            },\n            () => {\n                if (this.props.onSwitching) {\n                    this.props.onSwitching(indexNew, \"end\");\n                }\n\n                if (this.props.onChangeIndex && indexNew !== indexLatest) {\n                    this.props.onChangeIndex(indexNew, indexLatest, {\n                        reason: \"swipe\",\n                    });\n                }\n\n                // Manually calling handleTransitionEnd in that case as isn't otherwise.\n                if (indexCurrent === indexLatest) {\n                    this.handleTransitionEnd();\n                }\n            }\n        );\n    };\n\n    handleTouchStart = (event) => {\n        if (this.props.onTouchStart) {\n            this.props.onTouchStart(event);\n        }\n        this.handleSwipeStart(event);\n    };\n\n    handleTouchEnd = (event) => {\n        if (this.props.onTouchEnd) {\n            this.props.onTouchEnd(event);\n        }\n        this.handleSwipeEnd(event);\n    };\n\n    handleMouseDown = (event) => {\n        if (this.props.onMouseDown) {\n            this.props.onMouseDown(event);\n        }\n        event.persist();\n        this.handleSwipeStart(adaptMouse(event));\n    };\n\n    handleMouseUp = (event) => {\n        if (this.props.onMouseUp) {\n            this.props.onMouseUp(event);\n        }\n        this.handleSwipeEnd(adaptMouse(event));\n    };\n\n    handleMouseLeave = (event) => {\n        if (this.props.onMouseLeave) {\n            this.props.onMouseLeave(event);\n        }\n\n        // Filter out events\n        if (this.started) {\n            this.handleSwipeEnd(adaptMouse(event));\n        }\n    };\n\n    handleMouseMove = (event) => {\n        if (this.props.onMouseMove) {\n            this.props.onMouseMove(event);\n        }\n\n        // Filter out events\n        if (this.started) {\n            this.handleSwipeMove(adaptMouse(event));\n        }\n    };\n\n    handleScroll = (event) => {\n        if (this.props.onScroll) {\n            this.props.onScroll(event);\n        }\n\n        // Ignore events bubbling up.\n        if (event.target !== this.rootNode) {\n            return;\n        }\n\n        if (this.ignoreNextScrollEvents) {\n            this.ignoreNextScrollEvents = false;\n            return;\n        }\n\n        const indexLatest = this.state.indexLatest;\n        const indexNew = Math.ceil(event.target.scrollLeft / event.target.clientWidth) + indexLatest;\n\n        this.ignoreNextScrollEvents = true;\n        // Reset the scroll position.\n        event.target.scrollLeft = 0;\n\n        if (this.props.onChangeIndex && indexNew !== indexLatest) {\n            this.props.onChangeIndex(indexNew, indexLatest, {\n                reason: \"focus\",\n            });\n        }\n    };\n\n    updateHeight = () => {\n        if (this.activeSlide !== null) {\n            const child = this.activeSlide.children[0];\n            if (child !== undefined && child.offsetHeight !== undefined && this.state.heightLatest !== child.offsetHeight) {\n                this.setState({\n                    heightLatest: child.offsetHeight,\n                });\n            }\n        }\n    };\n\n    handleTransitionEnd() {\n        if (!this.props.onTransitionEnd) {\n            return;\n        }\n\n        // Filters out when changing the children\n        if (this.state.displaySameSlide) {\n            return;\n        }\n\n        // The rest callback is triggered when swiping. It's just noise.\n        // We filter it out.\n        if (!this.state.isDragging) {\n            this.props.onTransitionEnd();\n        }\n    }\n\n    render() {\n        const {\n            action,\n            animateHeight,\n            animateTransitions,\n            axis,\n            children,\n            containerStyle: containerStyleProp,\n            disabled,\n            disableLazyLoading,\n            enableMouseEvents,\n            hysteresis,\n            ignoreNativeScroll,\n            index,\n            onChangeIndex,\n            onSwitching,\n            onTransitionEnd,\n            resistance,\n            slideStyle: slideStyleProp,\n            slideClassName,\n            springConfig,\n            style,\n            threshold,\n            ...other\n        } = this.props;\n\n        const { displaySameSlide, heightLatest, indexLatest, isDragging, renderOnlyActive } = this.state;\n        const touchEvents = !disabled\n            ? {\n                  onTouchStart: this.handleTouchStart,\n                  onTouchEnd: this.handleTouchEnd,\n              }\n            : {};\n        const mouseEvents =\n            !disabled && enableMouseEvents\n                ? {\n                      onMouseDown: this.handleMouseDown,\n                      onMouseUp: this.handleMouseUp,\n                      onMouseLeave: this.handleMouseLeave,\n                      onMouseMove: this.handleMouseMove,\n                  }\n                : {};\n\n        // There is no point to animate if we are already providing a height.\n        warning(\n            !animateHeight || !containerStyleProp || !containerStyleProp.height,\n            `react-swipeable-view: You are setting animateHeight to true but you are\nalso providing a custom height.\nThe custom height has a higher priority than the animateHeight property.\nSo animateHeight is most likely having no effect at all.`\n        );\n\n        const slideStyle = Object.assign({}, styles.slide, slideStyleProp);\n\n        let transition;\n        let WebkitTransition;\n\n        if (isDragging || !animateTransitions || displaySameSlide) {\n            transition = \"all 0s ease 0s\";\n            WebkitTransition = \"all 0s ease 0s\";\n        } else {\n            transition = createTransition(\"transform\", springConfig);\n            WebkitTransition = createTransition(\"-webkit-transform\", springConfig);\n\n            if (heightLatest !== 0) {\n                const additionalTranstion = `, ${createTransition(\"height\", springConfig)}`;\n                transition += additionalTranstion;\n                WebkitTransition += additionalTranstion;\n            }\n        }\n\n        const containerStyle = {\n            height: null,\n            WebkitFlexDirection: axisProperties.flexDirection[axis],\n            flexDirection: axisProperties.flexDirection[axis],\n            WebkitTransition,\n            transition,\n        };\n\n        // Apply the styles for SSR considerations\n        if (!renderOnlyActive) {\n            const transform = axisProperties.transform[axis](this.indexCurrent * 100);\n            containerStyle.WebkitTransform = transform;\n            containerStyle.transform = transform;\n        }\n\n        if (animateHeight) {\n            containerStyle.height = heightLatest;\n        }\n\n        return (\n            <SwipeableViewsContext.Provider value={this.getSwipeableViewsContext()}>\n                <div\n                    ref={this.setRootNode}\n                    style={Object.assign({}, axisProperties.root[axis], style)}\n                    {...other}\n                    {...touchEvents}\n                    {...mouseEvents}\n                    onScroll={this.handleScroll}>\n                    <div\n                        ref={this.setContainerNode}\n                        style={Object.assign({}, containerStyle, styles.container, containerStyleProp)}\n                        className=\"react-swipeable-view-container\">\n                        {React.Children.map(children, (child, indexChild) => {\n                            if (renderOnlyActive && indexChild !== indexLatest) {\n                                return null;\n                            }\n\n                            warning(\n                                React.isValidElement(child),\n                                `react-swipeable-view: one of the children provided is invalid: ${child}.\n  We are expecting a valid React Element`\n                            );\n\n                            let ref;\n                            let hidden = true;\n\n                            if (indexChild === indexLatest) {\n                                hidden = false;\n\n                                if (animateHeight) {\n                                    ref = this.setActiveSlide;\n                                    slideStyle.overflowY = \"hidden\";\n                                }\n                            }\n\n                            return (\n                                <div ref={ref} style={slideStyle} className={slideClassName} aria-hidden={hidden} data-swipeable=\"true\">\n                                    {child}\n                                </div>\n                            );\n                        })}\n                    </div>\n                </div>\n            </SwipeableViewsContext.Provider>\n        );\n    }\n}\n\n// Added as an ads for people using the React dev tools in production.\n// So they know, the tool used to build the awesome UI they\n// are looking at/retro engineering.\nSliderViews.displayName = \"ReactSliderViews\";\n\nSliderViews.propTypes = {\n    /**\n     * This is callback property. It's called by the component on mount.\n     * This is useful when you want to trigger an action programmatically.\n     * It currently only supports updateHeight() action.\n     *\n     * @param {object} actions This object contains all posible actions\n     * that can be triggered programmatically.\n     */\n    action: PropTypes.func,\n    /**\n     * If `true`, the height of the container will be animated to match the current slide height.\n     * Animating another style property has a negative impact regarding performance.\n     */\n    animateHeight: PropTypes.bool,\n    /**\n     * If `false`, changes to the index prop will not cause an animated transition.\n     */\n    animateTransitions: PropTypes.bool,\n    /**\n     * The axis on which the slides will slide.\n     */\n    axis: PropTypes.oneOf([\"x\", \"x-reverse\", \"y\", \"y-reverse\"]),\n    /**\n     * Use this property to provide your slides.\n     */\n    children: PropTypes.node.isRequired,\n    /**\n     * This is the inlined style that will be applied\n     * to each slide container.\n     */\n    containerStyle: PropTypes.object,\n    /**\n     * If `true`, it will disable touch events.\n     * This is useful when you want to prohibit the user from changing slides.\n     */\n    disabled: PropTypes.bool,\n    /**\n     * This is the config used to disable lazyloding,\n     * if `true` will render all the views in first rendering.\n     */\n    disableLazyLoading: PropTypes.bool,\n    /**\n     * If `true`, it will enable mouse events.\n     * This will allow the user to perform the relevant swipe actions with a mouse.\n     */\n    enableMouseEvents: PropTypes.bool,\n    /**\n     * Configure hysteresis between slides. This value determines how far\n     * should user swipe to switch slide.\n     */\n    hysteresis: PropTypes.number,\n    /**\n     * If `true`, it will ignore native scroll container.\n     * It can be used to filter out false positive that blocks the swipe.\n     */\n    ignoreNativeScroll: PropTypes.bool,\n    /**\n     * This is the index of the slide to show.\n     * This is useful when you want to change the default slide shown.\n     * Or when you have tabs linked to each slide.\n     */\n    index: PropTypes.number,\n    /**\n     * This is callback prop. It's call by the\n     * component when the shown slide change after a swipe made by the user.\n     * This is useful when you have tabs linked to each slide.\n     *\n     * @param {integer} index This is the current index of the slide.\n     * @param {integer} indexLatest This is the oldest index of the slide.\n     * @param {object} meta Meta data containing more information about the event.\n     */\n    onChangeIndex: PropTypes.func,\n    /**\n     * @ignore\n     */\n    onMouseDown: PropTypes.func,\n    /**\n     * @ignore\n     */\n    onMouseLeave: PropTypes.func,\n    /**\n     * @ignore\n     */\n    onMouseMove: PropTypes.func,\n    /**\n     * @ignore\n     */\n    onMouseUp: PropTypes.func,\n    /**\n     * @ignore\n     */\n    onScroll: PropTypes.func,\n    /**\n     * This is callback prop. It's called by the\n     * component when the slide switching.\n     * This is useful when you want to implement something corresponding\n     * to the current slide position.\n     *\n     * @param {integer} index This is the current index of the slide.\n     * @param {string} type Can be either `move` or `end`.\n     */\n    onSwitching: PropTypes.func,\n    /**\n     * @ignore\n     */\n    onTouchEnd: PropTypes.func,\n    /**\n     * @ignore\n     */\n    onTouchMove: PropTypes.func,\n    /**\n     * @ignore\n     */\n    onTouchStart: PropTypes.func,\n    /**\n     * The callback that fires when the animation comes to a rest.\n     * This is useful to defer CPU intensive task.\n     */\n    onTransitionEnd: PropTypes.func,\n    /**\n     * If `true`, it will add bounds effect on the edges.\n     */\n    resistance: PropTypes.bool,\n    /**\n     * This is the className that will be applied\n     * on the slide component.\n     */\n    slideClassName: PropTypes.string,\n    /**\n     * This is the inlined style that will be applied\n     * on the slide component.\n     */\n    slideStyle: PropTypes.object,\n    /**\n     * This is the config used to create CSS transitions.\n     * This is useful to change the dynamic of the transition.\n     */\n    springConfig: PropTypes.shape({\n        delay: PropTypes.string,\n        duration: PropTypes.string,\n        easeFunction: PropTypes.string,\n    }),\n    /**\n     * This is the inlined style that will be applied\n     * on the root component.\n     */\n    style: PropTypes.object,\n    /**\n     * This is the threshold used for detecting a quick swipe.\n     * If the computed speed is above this value, the index change.\n     */\n    threshold: PropTypes.number,\n};\n\nSliderViews.defaultProps = {\n    animateHeight: false,\n    animateTransitions: true,\n    axis: \"x\",\n    disabled: false,\n    disableLazyLoading: false,\n    enableMouseEvents: false,\n    hysteresis: 0.6,\n    ignoreNativeScroll: false,\n    index: 0,\n    threshold: 5,\n    springConfig: {\n        duration: \"0.35s\",\n        easeFunction: \"cubic-bezier(0.15, 0.3, 0.25, 1)\",\n        delay: \"0s\",\n    },\n    resistance: false,\n};\n\nexport default SliderViews;\n"],"names":["addEventListener","node","event","handler","options","remove","removeEventListener","styles","direction","display","willChange","width","WebkitFlexShrink","flexShrink","overflow","axisProperties","root","x","overflowX","y","overflowY","flexDirection","transform","translate","concat","length","rotationMatrix","scrollPosition","scrollLength","clientLength","createTransition","property","duration","easeFunction","delay","applyRotationMatrix","touch","axis","pageX","pageY","adaptMouse","touches","getDomTreeShapes","element","rootNode","domTreeShapes","document","body","hasAttribute","style","window","getComputedStyle","getPropertyValue","clientWidth","scrollWidth","clientHeight","scrollHeight","push","scrollLeft","scrollTop","parentNode","nodeWhoClaimedTheScroll","findNativeHandler","params","startX","some","shape","goingForward","Math","round","areNotAtStart","areNotAtEnd","SwipeableViewsContext","React","createContext","process","env","NODE_ENV","displayName","SliderViews","Component","props","_this","_classCallCheck","this","_defineProperty","_assertThisInitialized","_super","call","undefined","containerNode","activeSlide","updateHeight","viewLength","getBoundingClientRect","lastX","vx","startY","isSwiping","started","computedStyle","transformValues","split","rootStyle","tranformNormalized","parseInt","startIndex","paddingLeft","paddingRight","_this$props","children","ignoreNativeScroll","onSwitching","resistance","dx","abs","dy","constant","UNCERTAINTY_THRESHOLD","indexCurrent","Children","count","preventDefault","_computeIndex","computeIndex","index","target","setIndexCurrent","callback","state","displaySameSlide","isDragging","setState","handleTouchStart","indexNew","indexLatest","delta","threshold","floor","ceil","hysteresis","indexMax","onChangeIndex","reason","handleTransitionEnd","onTouchStart","handleSwipeStart","onTouchEnd","handleSwipeEnd","onMouseDown","persist","onMouseUp","onMouseLeave","onMouseMove","handleSwipeMove","onScroll","ignoreNextScrollEvents","child","offsetHeight","heightLatest","checkIndexBounds","renderOnlyActive","disableLazyLoading","_this2","transitionListener","touchMoveListener","disabled","passive","firstRenderTimeout","setTimeout","action","prevProps","prevState","getDisplaySameSlide","clearTimeout","_this3","slideUpdateHeight","value","animateTransitions","WebkitTransform","onTransitionEnd","_this4","_this$props2","animateHeight","containerStyleProp","containerStyle","enableMouseEvents","slideStyleProp","slideStyle","slideClassName","springConfig","other","_objectWithoutProperties","_excluded","_this$state","touchEvents","handleTouchEnd","mouseEvents","handleMouseDown","handleMouseUp","handleMouseLeave","handleMouseMove","warning","height","transition","WebkitTransition","Object","assign","additionalTranstion","WebkitFlexDirection","createElement","Provider","getSwipeableViewsContext","_extends","ref","setRootNode","handleScroll","setContainerNode","className","map","indexChild","isValidElement","hidden","setActiveSlide","propTypes","PropTypes","func","bool","oneOf","isRequired","object","number","onTouchMove","string","defaultProps"],"mappings":"sqFAKA,SAASA,EAAiBC,EAAMC,EAAOC,EAASC,GAE5C,OADAH,EAAKD,iBAAiBE,EAAOC,EAASC,GAC/B,CACHC,OAAS,WACLJ,EAAKK,oBAAoBJ,EAAOC,EAASC,EAC5C,EAER,CAED,IAAMG,EACS,CACPC,UAAW,MACXC,QAAS,OACTC,WAAY,aAJdH,EAMK,CACHI,MAAO,OACPC,iBAAkB,EAClBC,WAAY,EACZC,SAAU,QAIZC,EAAiB,CACnBC,KAAM,CACFC,EAAG,CACCC,UAAW,UAEf,YAAa,CACTA,UAAW,UAEfC,EAAG,CACCC,UAAW,UAEf,YAAa,CACTA,UAAW,WAGnBC,cAAe,CACXJ,EAAG,MACH,YAAa,cACbE,EAAG,SACH,YAAa,kBAEjBG,UAAW,CACPL,EAAG,SAACM,GAAD,MAAA,aAAAC,QAA6BD,EAA7B,QADI,EAEP,YAAa,SAACA,GAAD,MAAA,aAAAC,OAA4BD,EAA5B,QAFN,EAGPJ,EAAG,SAACI,GAAD,MAAA,gBAAAC,QAAgCD,EAAhC,KAHI,EAIP,YAAa,SAACA,GAAD,MAAA,gBAAAC,OAA+BD,EAA/B,KAAA,GAEjBE,OAAQ,CACJR,EAAG,QACH,YAAa,QACbE,EAAG,SACH,YAAa,UAEjBO,eAAgB,CACZT,EAAG,CACCA,EAAG,CAAC,EAAG,GACPE,EAAG,CAAC,EAAG,IAEX,YAAa,CACTF,EAAG,EAAE,EAAG,GACRE,EAAG,CAAC,EAAG,IAEXA,EAAG,CACCF,EAAG,CAAC,EAAG,GACPE,EAAG,CAAC,EAAG,IAEX,YAAa,CACTF,EAAG,CAAC,GAAI,GACRE,EAAG,CAAC,EAAG,KAGfQ,eAAgB,CACZV,EAAG,aACH,YAAa,aACbE,EAAG,YACH,YAAa,aAEjBS,aAAc,CACVX,EAAG,cACH,YAAa,cACbE,EAAG,eACH,YAAa,gBAEjBU,aAAc,CACVZ,EAAG,cACH,YAAa,cACbE,EAAG,eACH,YAAa,iBAIrB,SAASW,EAAiBC,EAAU3B,GAChC,IAAQ4B,EAAkC5B,EAAlC4B,SAAUC,EAAwB7B,EAAxB6B,aAAcC,EAAU9B,EAAV8B,MAEhC,MAAA,GAAAV,OAAUO,EAAYC,KAAAA,OAAAA,EAAYC,KAAAA,OAAAA,cAAgBC,EACrD,CAGD,SAASC,EAAoBC,EAAOC,GAChC,IAAMX,EAAiBX,EAAeW,eAAeW,GAErD,MAAO,CACHC,MAAOZ,EAAeT,EAAE,GAAKmB,EAAME,MAAQZ,EAAeT,EAAE,GAAKmB,EAAMG,MACvEA,MAAOb,EAAeP,EAAE,GAAKiB,EAAME,MAAQZ,EAAeP,EAAE,GAAKiB,EAAMG,MAE9E,CAED,SAASC,EAAWtC,GAEhB,OADAA,EAAMuC,QAAU,CAAC,CAAEH,MAAOpC,EAAMoC,MAAOC,MAAOrC,EAAMqC,QAC7CrC,CACV,CAEM,SAASwC,EAAiBC,EAASC,GAGtC,IAFA,IAAIC,EAAgB,GAEbF,GAAWA,IAAYC,GAAYD,IAAYG,SAASC,OAEvDJ,EAAQK,aAAa,mBAFwC,CAMjE,IAAMC,EAAQC,OAAOC,iBAAiBR,GAIK,aAAvCM,EAAMG,iBAAiB,aAEkB,WAAzCH,EAAMG,iBAAiB,cAEvBP,EAAgB,IAEfF,EAAQU,YAAc,GAAKV,EAAQW,YAAcX,EAAQU,aACzDV,EAAQY,aAAe,GAAKZ,EAAQa,aAAeb,EAAQY,eAI5DV,EAAcY,KAAK,CACfd,QAAAA,EACAW,YAAaX,EAAQW,YACrBE,aAAcb,EAAQa,aACtBH,YAAaV,EAAQU,YACrBE,aAAcZ,EAAQY,aACtBG,WAAYf,EAAQe,WACpBC,UAAWhB,EAAQgB,YAI3BhB,EAAUA,EAAQiB,UACrB,CAED,OAAOf,CACV,CAKD,IAAIgB,EAA0B,KAEvB,SAASC,EAAkBC,GAC9B,IAAQlB,EAAuCkB,EAAvClB,cAAeP,EAAwByB,EAAxBzB,MAAO0B,EAAiBD,EAAjBC,OAAQ3B,EAAS0B,EAAT1B,KAEtC,OAAOQ,EAAcoB,MAAK,SAACC,GAEvB,IAAIC,EAAe7B,GAAS0B,EACf,MAAT3B,GAAyB,MAATA,IAChB8B,GAAgBA,GAKpB,IAAMxC,EAAiByC,KAAKC,MAAMH,EAAMnD,EAAeY,eAAeU,KAEhEiC,EAAgB3C,EAAiB,EACjC4C,EAAc5C,EAAiBuC,EAAMnD,EAAec,aAAaQ,IAAS6B,EAAMnD,EAAea,aAAaS,IAElH,SAAK8B,GAAgBI,IAAkBJ,GAAgBG,KACnDT,EAA0BK,EAAMvB,SACzB,EAId,GACJ,KAEY6B,EAAwBC,EAAMC,gBAEd,eAAzBC,QAAQC,IAAIC,WACZL,EAAsBM,YAAc,0BAGlCC,uSAAoBN,EAAMO,4BAkB5B,SAAAD,EAAYE,GAAO,IAAAC,EAAA,mGAAAC,CAAAC,KAAAL,GAAAM,EAAAC,EACfJ,EAAAK,EAAAC,KAAAJ,KAAMH,IADS,WAjBR,MAiBQI,EAAAC,EAAAJ,GAAA,gBAhBH,MAgBGG,EAAAC,EAAAJ,GAAA,0BAfM,GAeNG,EAAAC,EAAAJ,GAAA,aAdN,GAcMG,EAAAC,EAAAJ,GAAA,SAbV,GAaUG,EAAAC,EAAAJ,GAAA,QAZX,GAYWG,EAAAC,EAAAJ,GAAA,KAXd,GAWcG,EAAAC,EAAAJ,GAAA,SAVV,GAUUG,EAAAC,EAAAJ,GAAA,iBATPO,GASOJ,EAAAC,EAAAJ,GAAA,WART,GAQSG,EAAAC,EAAAJ,GAAA,aAPN,GAOMG,EAAAC,EAAAJ,GAAA,qBANE,MAMFG,EAAAC,EAAAJ,GAAA,oBALC,MAKDG,EAAAC,EAAAJ,GAAA,cAJL,MAIKG,EAAAC,EAAAJ,GAAA,eAHJ,MAGIG,EAAAC,EAAAJ,GAAA,qBAFE,MAEFG,EAkILC,EAAAJ,GAAA,eAAA,SAACjF,GACXiF,EAAKtC,SAAW3C,KAnIDoF,EAsIAC,EAAAJ,GAAA,oBAAA,SAACjF,GAChBiF,EAAKQ,cAAgBzF,KAvINoF,EA0IFC,EAAAJ,GAAA,kBAAA,SAACjF,GACdiF,EAAKS,YAAc1F,EACnBiF,EAAKU,kBA5IUP,EA+IAC,EAAAJ,GAAA,oBAAA,SAAChF,GAChB,IAAQmC,EAAS6C,EAAKD,MAAd5C,KAEFD,EAAQD,EAAoBjC,EAAMuC,QAAQ,GAAIJ,GAEpD6C,EAAKW,WAAaX,EAAKtC,SAASkD,wBAAwB/E,EAAeU,OAAOY,IAC9E6C,EAAKlB,OAAS5B,EAAME,MACpB4C,EAAKa,MAAQ3D,EAAME,MACnB4C,EAAKc,GAAK,EACVd,EAAKe,OAAS7D,EAAMG,MACpB2C,EAAKgB,eAAYT,EACjBP,EAAKiB,SAAU,EAEf,IAAMC,EAAgBlD,OAAOC,iBAAiB+B,EAAKQ,eAC7CpE,EAAY8E,EAAchD,iBAAiB,sBAAwBgD,EAAchD,iBAAiB,aAExG,GAAI9B,GAA2B,SAAdA,EAAsB,CACnC,IAAM+E,EAAkB/E,EAAUgF,MAAM,KAAK,GAAGA,MAAM,KAAK,GAAGA,MAAM,KAC9DC,EAAYrD,OAAOC,iBAAiB+B,EAAKtC,UAEzC4D,EAAqBrE,EACvB,CACIG,MAAOmE,SAASJ,EAAgB,GAAI,IACpC9D,MAAOkE,SAASJ,EAAgB,GAAI,KAExChE,GAGJ6C,EAAKwB,YACAF,EAAmBlE,OAAS4C,EAAKW,WAAaY,SAASF,EAAUI,YAAa,IAAMF,SAASF,EAAUK,aAAc,MAAQ,CACrI,KA7KcvB,EAgLDC,EAAAJ,GAAA,mBAAA,SAAChF,GAGf,GAAKgF,EAAKiB,SAMV,GAAgC,OAA5BtC,GAAoCA,IAA4BqB,EAAKtC,SAAzE,CAIA,IAAAiE,EAAwE3B,EAAKD,MAArE5C,IAAAA,KAAMyE,IAAAA,SAAUC,IAAAA,mBAAoBC,IAAAA,YAAaC,IAAAA,WACnD7E,EAAQD,EAAoBjC,EAAMuC,QAAQ,GAAIJ,GAGpD,QAAuBoD,IAAnBP,EAAKgB,UAAyB,CAC9B,IAAMgB,EAAK9C,KAAK+C,IAAI/E,EAAME,MAAQ4C,EAAKlB,QACjCoD,EAAKhD,KAAK+C,IAAI/E,EAAMG,MAAQ2C,EAAKe,QAEjCC,EAAYgB,EAAKE,GAAMF,EAAKG,EAAAA,SAASC,sBAG3C,IACKL,IACS,MAAT5E,GAAyB,cAATA,KACO,IAAtB6C,EAAKqC,cAAsBrC,EAAKlB,OAAS5B,EAAME,OAC5C4C,EAAKqC,eAAiB9C,EAAM+C,SAASC,MAAMvC,EAAKD,MAAM6B,UAAY,GAAK5B,EAAKlB,OAAS5B,EAAME,OAGhG,YADA4C,EAAKgB,WAAY,GASrB,GAJIgB,EAAKE,GACLlH,EAAMwH,kBAGQ,IAAdxB,GAAsBkB,EAAKC,EAAAA,SAASC,sBAIpC,OAHApC,EAAKgB,UAAYA,OACjBhB,EAAKlB,OAAS5B,EAAME,MAI3B,CAED,IAAuB,IAAnB4C,EAAKgB,UAAT,CAKAhG,EAAMwH,iBAGNxC,EAAKc,GAAe,GAAVd,EAAKc,GAAwC,IAA5B5D,EAAME,MAAQ4C,EAAKa,OAC9Cb,EAAKa,MAAQ3D,EAAME,MAEnB,IAAAqF,EAA0BC,EAAAA,aAAa,CACnCd,SAAAA,EACAG,WAAAA,EACA3E,MAAOF,EAAME,MACboE,WAAYxB,EAAKwB,WACjB1C,OAAQkB,EAAKlB,OACb6B,WAAYX,EAAKW,aANbgC,IAAAA,MAAO7D,EAAf2D,EAAe3D,OAUf,GAAgC,OAA5BH,IAAqCkD,EAUrC,GAR8BjD,EAAkB,CAC5CjB,cAFkBH,EAAiBxC,EAAM4H,OAAQ5C,EAAKtC,UAGtDoB,OAAQkB,EAAKlB,OACb1B,MAAOF,EAAME,MACbD,KAAAA,IAKA,OAKJ2B,EACAkB,EAAKlB,OAASA,EACqB,OAA5BH,IACPA,EAA0BqB,EAAKtC,UAGnCsC,EAAK6C,gBAAgBF,GAErB,IAAMG,EAAW,WACThB,GACAA,EAAYa,EAAO,UAIvB3C,EAAK+C,MAAMC,kBAAqBhD,EAAK+C,MAAME,YAC3CjD,EAAKkD,SACD,CACIF,kBAAkB,EAClBC,YAAY,GAEhBH,GAIRA,GA5GyB,CAWxB,OAPG9C,EAAKmD,iBAAiBnI,MApLXmF,EAAAC,EAAAJ,GAAA,kBA+RF,WAKb,GAJArB,EAA0B,KAIrBqB,EAAKiB,UAIVjB,EAAKiB,SAAU,GAEQ,IAAnBjB,EAAKgB,WAAT,CAIA,IAIIoC,EAJEC,EAAcrD,EAAK+C,MAAMM,YACzBhB,EAAerC,EAAKqC,aACpBiB,EAAQD,EAAchB,EAOpBe,EAFJlE,KAAK+C,IAAIjC,EAAKc,IAAMd,EAAKD,MAAMwD,UAC3BvD,EAAKc,GAAK,EACC5B,KAAKsE,MAAMnB,GAEXnD,KAAKuE,KAAKpB,GAElBnD,KAAK+C,IAAIqB,GAAStD,EAAKD,MAAM2D,WAEzBJ,EAAQ,EAAIpE,KAAKsE,MAAMnB,GAAgBnD,KAAKuE,KAAKpB,GAEjDgB,EAGf,IAAMM,EAAWpE,EAAM+C,SAASC,MAAMvC,EAAKD,MAAM6B,UAAY,EAEzDwB,EAAW,EACXA,EAAW,EACJA,EAAWO,IAClBP,EAAWO,GAGf3D,EAAK6C,gBAAgBO,GACrBpD,EAAKkD,SACD,CACIG,YAAaD,EACbH,YAAY,IAEhB,WACQjD,EAAKD,MAAM+B,aACX9B,EAAKD,MAAM+B,YAAYsB,EAAU,OAGjCpD,EAAKD,MAAM6D,eAAiBR,IAAaC,GACzCrD,EAAKD,MAAM6D,cAAcR,EAAUC,EAAa,CAC5CQ,OAAQ,UAKZxB,IAAiBgB,GACjBrD,EAAK8D,wBAjDhB,KA5Sc3D,EAmWAC,EAAAJ,GAAA,oBAAA,SAAChF,GACZgF,EAAKD,MAAMgE,cACX/D,EAAKD,MAAMgE,aAAa/I,GAE5BgF,EAAKgE,iBAAiBhJ,MAvWPmF,EA0WFC,EAAAJ,GAAA,kBAAA,SAAChF,GACVgF,EAAKD,MAAMkE,YACXjE,EAAKD,MAAMkE,WAAWjJ,GAE1BgF,EAAKkE,eAAelJ,MA9WLmF,EAiXDC,EAAAJ,GAAA,mBAAA,SAAChF,GACXgF,EAAKD,MAAMoE,aACXnE,EAAKD,MAAMoE,YAAYnJ,GAE3BA,EAAMoJ,UACNpE,EAAKgE,iBAAiB1G,EAAWtC,OAtXlBmF,EAyXHC,EAAAJ,GAAA,iBAAA,SAAChF,GACTgF,EAAKD,MAAMsE,WACXrE,EAAKD,MAAMsE,UAAUrJ,GAEzBgF,EAAKkE,eAAe5G,EAAWtC,OA7XhBmF,EAgYAC,EAAAJ,GAAA,oBAAA,SAAChF,GACZgF,EAAKD,MAAMuE,cACXtE,EAAKD,MAAMuE,aAAatJ,GAIxBgF,EAAKiB,SACLjB,EAAKkE,eAAe5G,EAAWtC,OAvYpBmF,EA2YDC,EAAAJ,GAAA,mBAAA,SAAChF,GACXgF,EAAKD,MAAMwE,aACXvE,EAAKD,MAAMwE,YAAYvJ,GAIvBgF,EAAKiB,SACLjB,EAAKwE,gBAAgBlH,EAAWtC,OAlZrBmF,EAsZJC,EAAAJ,GAAA,gBAAA,SAAChF,GAMZ,GALIgF,EAAKD,MAAM0E,UACXzE,EAAKD,MAAM0E,SAASzJ,GAIpBA,EAAM4H,SAAW5C,EAAKtC,SAI1B,GAAIsC,EAAK0E,uBACL1E,EAAK0E,wBAAyB,MADlC,CAKA,IAAMrB,EAAcrD,EAAK+C,MAAMM,YACzBD,EAAWlE,KAAKuE,KAAKzI,EAAM4H,OAAOpE,WAAaxD,EAAM4H,OAAOzE,aAAekF,EAEjFrD,EAAK0E,wBAAyB,EAE9B1J,EAAM4H,OAAOpE,WAAa,EAEtBwB,EAAKD,MAAM6D,eAAiBR,IAAaC,GACzCrD,EAAKD,MAAM6D,cAAcR,EAAUC,EAAa,CAC5CQ,OAAQ,SAXf,KAnac1D,EAAAC,EAAAJ,GAAA,gBAmbJ,WACX,GAAyB,OAArBA,EAAKS,YAAsB,CAC3B,IAAMkE,EAAQ3E,EAAKS,YAAYmB,SAAS,QAC1BrB,IAAVoE,QAA8CpE,IAAvBoE,EAAMC,cAA8B5E,EAAK+C,MAAM8B,eAAiBF,EAAMC,cAC7F5E,EAAKkD,SAAS,CACV2B,aAAcF,EAAMC,cAG/B,KAxb4B,eAAzBnF,QAAQC,IAAIC,UACZmF,EAAgBA,iBAAC/E,GAGrBC,EAAK+C,MAAQ,CACTM,YAAatD,EAAM4C,MAGnBM,YAAY,EAEZ8B,kBAAmBhF,EAAMiF,mBACzBH,aAAc,EAEd7B,kBAAkB,GAEtBhD,EAAK6C,gBAAgB9C,EAAM4C,OAlBZ3C,CAmBlB,+CAED,WAAoB,IAAAiF,EAAA/E,KAEhBA,KAAKgF,mBAAqBpK,EAAiBoF,KAAKM,cAAe,iBAAiB,SAACxF,GACzEA,EAAM4H,SAAWqC,EAAKzE,eAI1ByE,EAAKnB,yBAIT5D,KAAKiF,kBAAoBrK,EACrBoF,KAAKxC,SACL,aACA,SAAC1C,GAEOiK,EAAKlF,MAAMqF,UAGfH,EAAKT,gBAAgBxJ,EACxB,GACD,CACIqK,SAAS,IAIZnF,KAAKH,MAAMiF,qBACZ9E,KAAKoF,mBAAqBC,YAAW,WACjCN,EAAK/B,SAAS,CACV6B,kBAAkB,GAFU,GAIjC,IAIH7E,KAAKH,MAAMyF,QACXtF,KAAKH,MAAMyF,OAAO,CACd9E,aAAcR,KAAKQ,iDA2B/B,SAAmB+E,EAAWC,GAC1B,IAAQ/C,EAAUzC,KAAKH,MAAf4C,MACa,iBAAVA,GAAsBA,IAAU8C,EAAU9C,QACpB,eAAzBlD,QAAQC,IAAIC,UACZmF,mBAAiB5E,KAAKH,OAG1BG,KAAK2C,gBAAgBF,GACrBzC,KAAKgD,SAAS,CAEVF,iBAAkB2C,EAAmBA,oBAACF,EAAWvF,KAAKH,OACtDsD,YAAaV,IAGxB,qCAED,WACIzC,KAAKgF,mBAAmB/J,SACxB+E,KAAKiF,kBAAkBhK,SACvByK,aAAa1F,KAAKoF,mBACrB,yCAED,WAA2B,IAAAO,EAAA3F,KACvB,MAAO,CACH4F,kBAAmB,WACfD,EAAKnF,cACR,EAER,0BAEDqF,MAAA,SAAgB1D,GAOZ,GANKnC,KAAKH,MAAMiG,oBAAsB9F,KAAKmC,eAAiBA,GACxDnC,KAAK4D,sBAGT5D,KAAKmC,aAAeA,EAEhBnC,KAAKM,cAAe,CACpB,IAAQrD,EAAS+C,KAAKH,MAAd5C,KACFf,EAAYP,EAAeO,UAAUe,GAAqB,IAAfkF,GACjDnC,KAAKM,cAAczC,MAAMkI,gBAAkB7J,EAC3C8D,KAAKM,cAAczC,MAAM3B,UAAYA,CACxC,CACJ,oCA8TD,WACS8D,KAAKH,MAAMmG,kBAKZhG,KAAK6C,MAAMC,kBAMV9C,KAAK6C,MAAME,YACZ/C,KAAKH,MAAMmG,kBAElB,uBAED,WAAS,IAAAC,EAAAjG,KACLkG,EAuBIlG,KAAKH,QAtBLyF,WACAa,IAAAA,cACAL,IAAAA,mBACA7I,IAAAA,KACAyE,IAAAA,SACgB0E,IAAhBC,eACAnB,IAAAA,WACAJ,uBACAwB,IAAAA,oBACA9C,aACA7B,qBACAc,QACAiB,gBACA9B,cACAoE,kBACAnE,eACY0E,IAAZC,WACAC,IAAAA,eACAC,IAAAA,aACA7I,IAAAA,QACAwF,UArBJ,IAsBOsD,EAtBPC,EAAAV,EAAAW,GAyBAC,EAAsF9G,KAAK6C,MAAnFC,IAAAA,iBAAkB6B,IAAAA,aAAcxB,IAAAA,YAAaJ,IAAAA,WAAY8B,IAAAA,iBAC3DkC,EAAe7B,EAKf,GAJA,CACIrB,aAAc7D,KAAKiD,iBACnBc,WAAY/D,KAAKgH,gBAGrBC,GACD/B,GAAYoB,EACP,CACIrC,YAAajE,KAAKkH,gBAClB/C,UAAWnE,KAAKmH,cAChB/C,aAAcpE,KAAKoH,iBACnB/C,YAAarE,KAAKqH,iBAEtB,GAGVC,EAAO,SACFnB,IAAkBC,IAAuBA,EAAmBmB,OADjE,gPAQA,IAEIC,EACAC,EAHEjB,EAAakB,OAAOC,OAAO,CAAd,EAAkBxM,EAAcoL,GAKnD,GAAIxD,IAAe+C,GAAsBhD,EACrC0E,EAAa,iBACbC,EAAmB,sBAKnB,GAHAD,EAAa9K,EAAiB,YAAagK,GAC3Ce,EAAmB/K,EAAiB,oBAAqBgK,GAEpC,IAAjB/B,EAAoB,CACpB,IAAMiD,cAA2BlL,EAAiB,SAAUgK,IAC5Dc,GAAcI,EACdH,GAAoBG,CACvB,CAGL,IAAMvB,EAAiB,CACnBkB,OAAQ,KACRM,oBAAqBlM,EAAeM,cAAcgB,GAClDhB,cAAeN,EAAeM,cAAcgB,GAC5CwK,iBAAAA,EACAD,WAAAA,GAIJ,IAAK3C,EAAkB,CACnB,IAAM3I,EAAYP,EAAeO,UAAUe,GAA0B,IAApB+C,KAAKmC,cACtDkE,EAAeN,gBAAkB7J,EACjCmK,EAAenK,UAAYA,CAC9B,CAMD,OAJIiK,IACAE,EAAekB,OAAS5C,GAIxBtF,EAAAyI,cAAC1I,EAAsB2I,SAAvB,CAAgClC,MAAO7F,KAAKgI,4BACxC3I,EAAAyI,cAAA,MAAAG,EAAA,CACIC,IAAKlI,KAAKmI,YACVtK,MAAO6J,OAAOC,OAAO,CAAd,EAAkBhM,EAAeC,KAAKqB,GAAOY,IAChD8I,EACAI,EACAE,EALR,CAMI1C,SAAUvE,KAAKoI,eACf/I,EAAAyI,cAAA,MAAA,CACII,IAAKlI,KAAKqI,iBACVxK,MAAO6J,OAAOC,OAAO,CAAA,EAAItB,EAAgBlL,EAAkBiL,GAC3DkC,UAAU,kCACTjJ,EAAM+C,SAASmG,IAAI7G,GAAU,SAAC+C,EAAO+D,GAClC,GAAI3D,GAAoB2D,IAAerF,EACnC,OAAO,KASX,IAAI+E,EANJZ,UACIjI,EAAMoJ,eAAehE,GAC6CA,kEAAAA,OAAAA,EAFtE,gDAOA,IAAIiE,GAAS,EAWb,OATIF,IAAerF,IACfuF,GAAS,EAELvC,IACA+B,EAAMjC,EAAK0C,eACXnC,EAAWxK,UAAY,WAK3BqD,EAAAyI,cAAA,MAAA,CAAKI,IAAKA,EAAKrK,MAAO2I,EAAY8B,UAAW7B,EAAgB,cAAaiC,EAAQ,iBAAe,QAC5FjE,QAQhC,yFAML9E,EAAYD,YAAc,mBAE1BC,EAAYiJ,UAAY,eAAArJ,QAAAC,IAAAC,SAAA,CASpB6F,OAAQuD,EAAS,QAACC,KAKlB3C,cAAe0C,EAAS,QAACE,KAIzBjD,mBAAoB+C,EAAS,QAACE,KAI9B9L,KAAM4L,EAAS,QAACG,MAAM,CAAC,IAAK,YAAa,IAAK,cAI9CtH,SAAUmH,EAAAA,QAAUhO,KAAKoO,WAKzB5C,eAAgBwC,EAAS,QAACK,OAK1BhE,SAAU2D,EAAS,QAACE,KAKpBjE,mBAAoB+D,EAAS,QAACE,KAK9BzC,kBAAmBuC,EAAS,QAACE,KAK7BvF,WAAYqF,EAAS,QAACM,OAKtBxH,mBAAoBkH,EAAS,QAACE,KAM9BtG,MAAOoG,EAAS,QAACM,OAUjBzF,cAAemF,EAAS,QAACC,KAIzB7E,YAAa4E,EAAS,QAACC,KAIvB1E,aAAcyE,EAAS,QAACC,KAIxBzE,YAAawE,EAAS,QAACC,KAIvB3E,UAAW0E,EAAS,QAACC,KAIrBvE,SAAUsE,EAAS,QAACC,KAUpBlH,YAAaiH,EAAS,QAACC,KAIvB/E,WAAY8E,EAAS,QAACC,KAItBM,YAAaP,EAAS,QAACC,KAIvBjF,aAAcgF,EAAS,QAACC,KAKxB9C,gBAAiB6C,EAAS,QAACC,KAI3BjH,WAAYgH,EAAS,QAACE,KAKtBtC,eAAgBoC,EAAS,QAACQ,OAK1B7C,WAAYqC,EAAS,QAACK,OAKtBxC,aAAcmC,EAAS,QAAC/J,MAAM,CAC1BhC,MAAO+L,EAAS,QAACQ,OACjBzM,SAAUiM,EAAS,QAACQ,OACpBxM,aAAcgM,EAAS,QAACQ,SAM5BxL,MAAOgL,EAAS,QAACK,OAKjB7F,UAAWwF,EAAS,QAACM,QAxJzB,GA2JAxJ,EAAY2J,aAAe,CACvBnD,eAAe,EACfL,oBAAoB,EACpB7I,KAAM,IACNiI,UAAU,EACVJ,oBAAoB,EACpBwB,mBAAmB,EACnB9C,WAAY,GACZ7B,oBAAoB,EACpBc,MAAO,EACPY,UAAW,EACXqD,aAAc,CACV9J,SAAU,QACVC,aAAc,mCACdC,MAAO,MAEX+E,YAAY"}